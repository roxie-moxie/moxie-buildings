---
phase: 01-foundation
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/moxie/normalizer.py
  - src/moxie/sync/__init__.py
  - tests/__init__.py
  - tests/test_normalizer.py
autonomous: true
requirements:
  - DATA-03

must_haves:
  truths:
    - "normalize() converts a raw scraper dict to a DB-ready dict with rent_cents as integer cents"
    - "normalize() maps all known bed type aliases to canonical values (Studio, Convertible, 1BR, 1BR+Den, 2BR, 3BR+)"
    - "normalize() sets non_canonical=True for bed types that do not match any known alias, and stores the raw value as-is"
    - "normalize() converts any parseable date string (including 'Available Now') to YYYY-MM-DD format"
    - "normalize() passes optional fields through when provided and leaves them None when absent"
    - "Missing required fields (unit_number, bed_type, rent, availability_date) cause a Pydantic ValidationError at normalize() call time — not silently"
  artifacts:
    - path: "src/moxie/normalizer.py"
      provides: "UnitInput Pydantic model + normalize() function"
      contains: "CANONICAL_BED_TYPES"
    - path: "tests/test_normalizer.py"
      provides: "Full test suite: rent, bed_type, dates, optional fields, non_canonical, error cases"
      min_lines: 80
  key_links:
    - from: "tests/test_normalizer.py"
      to: "src/moxie/normalizer.py"
      via: "from moxie.normalizer import normalize"
      pattern: "from moxie\\.normalizer import normalize"
---

<objective>
Build and test the normalizer — the single shared module that every scraper calls before writing to the database.

Purpose: The normalizer is a pure function with well-defined I/O contracts, making it the ideal TDD target. Tests written first define the contract Phase 2 scrapers must satisfy. A failing test on bad scraper output is the mechanism that enforces DATA-03.
Output: A fully tested normalizer with RED→GREEN→REFACTOR commits.
</objective>

<execution_context>
@C:/Users/eimil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/eimil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<feature>
  <name>Unit normalizer</name>
  <files>src/moxie/normalizer.py, tests/test_normalizer.py</files>
  <behavior>
The normalizer is a pure function: `normalize(raw: dict, building_id: int) -> dict`

It accepts raw scraper output (messy strings, integers, varied formats) and returns a DB-ready dict. It must NEVER touch the database. It raises Pydantic `ValidationError` on missing required fields.

**Bed type normalization — input → expected bed_type, non_canonical:**
- `"0"` → `"Studio"`, non_canonical=False
- `"0BR"` → `"Studio"`, non_canonical=False
- `"studio"` → `"Studio"`, non_canonical=False
- `"Studio"` → `"Studio"`, non_canonical=False
- `"convertible"` → `"Convertible"`, non_canonical=False
- `"alcove"` → `"Convertible"`, non_canonical=False
- `"jr 1br"` → `"Convertible"`, non_canonical=False
- `"1"` → `"1BR"`, non_canonical=False
- `"1br"` → `"1BR"`, non_canonical=False
- `"1 bed"` → `"1BR"`, non_canonical=False
- `"one bedroom"` → `"1BR"`, non_canonical=False
- `"1BR+Den"` → `"1BR+Den"`, non_canonical=False
- `"1br+den"` → `"1BR+Den"`, non_canonical=False
- `"1 bed den"` → `"1BR+Den"`, non_canonical=False
- `"2"` → `"2BR"`, non_canonical=False
- `"2br"` → `"2BR"`, non_canonical=False
- `"3"` → `"3BR+"`, non_canonical=False
- `"3br"` → `"3BR+"`, non_canonical=False
- `"4br"` → `"3BR+"`, non_canonical=False (4BR+ maps to 3BR+ per spec)
- `"PENTHOUSE"` → `"PENTHOUSE"`, non_canonical=True (unknown alias stored as-is)
- `"5BR"` → `"5BR"`, non_canonical=True

**Rent normalization — input → expected rent_cents:**
- `"$1,500.00"` → `150000`
- `"$1500"` → `150000`
- `1500` → `150000`
- `"2,250/mo"` → `225000`
- `"$3,000.00"` → `300000`
- `"$995"` → `99500`

**Date normalization — input → expected availability_date (YYYY-MM-DD):**
- `"Available Now"` → today's date as YYYY-MM-DD
- `"now"` → today's date
- `"2026-03-01"` → `"2026-03-01"` (passthrough)
- `"March 1, 2026"` → `"2026-03-01"`
- `"03/01/2026"` → `"2026-03-01"`
- `"3/1/26"` → `"2026-03-01"` (or equivalent two-digit year handling)

**Optional fields:**
- When floor_plan_name, floor_plan_url, baths, sqft are provided → present in output dict
- When not provided → present as None in output dict (not missing from dict)
- baths stored as string (per model: `Mapped[Optional[str]]`)
- sqft stored as int when provided

**Required field enforcement:**
- Missing unit_number → ValidationError
- Missing bed_type → ValidationError
- Missing rent → ValidationError
- Missing availability_date → ValidationError

**Output dict keys:**
`building_id`, `unit_number`, `bed_type`, `non_canonical`, `rent_cents`, `availability_date`, `floor_plan_name`, `floor_plan_url`, `baths`, `sqft`, `scrape_run_at`
  </behavior>
  <implementation>
Follow the research pattern (Pattern 4 in RESEARCH.md):
- `CANONICAL_BED_TYPES` set for O(1) lookup
- `BED_TYPE_ALIASES` dict mapping lowercased raw values to canonical forms
- `UnitInput(BaseModel)` with `@field_validator(mode="before")` for bed_type, rent, availability_date
- `normalize(raw: dict, building_id: int) -> dict` wraps UnitInput instantiation
- The `rent` field validator: strip `$`, commas, `/mo`; handle decimal (multiply by 100 as cents)
- The `availability_date` field validator: check for "available now"/"now"/"immediate" strings first (return today), then call `dateutil_parser.parse()` and format as YYYY-MM-DD
- The `bed_type` field validator: lowercase + strip, look up in BED_TYPE_ALIASES, return alias if found, else return original stripped value (not lowercased — preserve case for unknown values)
- `non_canonical` computed in `normalize()` after UnitInput validates: `inp.bed_type not in CANONICAL_BED_TYPES`
- `scrape_run_at` set to `datetime.utcnow()` inside `normalize()`

Use `python-dateutil` for date parsing (already in deps). Do NOT use `datetime.strptime` — format-agnostic parsing is required.
  </implementation>
</feature>

<tdd_cycles>

**RED cycle:**
1. Create `tests/__init__.py` (empty) and `src/moxie/sync/__init__.py` (empty, needed for package structure)
2. Create `tests/test_normalizer.py` with all test cases from the behavior section above
3. Run `uv run pytest tests/test_normalizer.py -v` — ALL tests must FAIL (ImportError or assertion failures)
4. Commit: `test(01-02): add failing normalizer tests`

**GREEN cycle:**
1. Create `src/moxie/normalizer.py` with the minimal implementation to make all tests pass
2. Run `uv run pytest tests/test_normalizer.py -v` — ALL tests must PASS
3. Commit: `feat(01-02): implement unit normalizer`

**REFACTOR cycle (if needed):**
1. Clean up: extract constants, add docstrings, remove any duplication
2. Run `uv run pytest tests/test_normalizer.py -v` — still PASS
3. Commit: `refactor(01-02): clean up normalizer` (only if changes were made)

</tdd_cycles>

<verification>
`uv run pytest tests/test_normalizer.py -v` — all tests pass, zero failures.
`uv run python -c "from moxie.normalizer import normalize; print(normalize({'unit_number': '101', 'bed_type': '0', 'rent': '$1,500.00', 'availability_date': 'Available Now'}, building_id=1))"` — returns dict with bed_type='Studio', rent_cents=150000, non_canonical=False, availability_date=today's date.
</verification>

<success_criteria>
- tests/test_normalizer.py has at least 15 test cases covering all behavior categories
- All test cases pass with `uv run pytest tests/test_normalizer.py -v`
- normalize() returns correct bed_type and non_canonical for all canonical aliases and unknown values
- normalize() returns rent_cents as integer (not float, not string)
- normalize() returns availability_date as YYYY-MM-DD string
- normalize() raises ValidationError on missing required fields
- Optional fields return as None (not missing key) when not provided
- Three git commits produced: test commit (RED), feat commit (GREEN), optional refactor
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Test cases written and what each covers
- Implementation decisions (alias dict, validator patterns used)
- Edge cases discovered during TDD
- Final pytest output (pass count)
</output>
